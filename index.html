<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>赵阳的blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="赵阳的blog">
<meta property="og:url" content="http://blog.zhaoyang.meizu.com/index.html">
<meta property="og:site_name" content="赵阳的blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="赵阳的blog">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="赵阳的blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">赵阳的blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Read &amp;&amp; Type The Fucking SourceCode.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog.zhaoyang.meizu.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    l<article id="post-Android爬虫-爬取V2ex职位信息" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/22/Android爬虫-爬取V2ex职位信息/" class="article-date">
  <time datetime="2016-08-22T13:34:51.000Z" itemprop="datePublished">2016-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/22/Android爬虫-爬取V2ex职位信息/">Android爬虫-爬取V2ex职位信息</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="https-github-com-zhaokidd-JobInfoCrawler"><a href="#https-github-com-zhaokidd-JobInfoCrawler" class="headerlink" title="https://github.com/zhaokidd/JobInfoCrawler"></a><a href="https://github.com/zhaokidd/JobInfoCrawler" target="_blank" rel="external">https://github.com/zhaokidd/JobInfoCrawler</a></h2><h5 id="自己写了爬取V2ex上职位信息的小爬虫程序-作为最近的练手程序-界面非常丑陋，几乎没有什么UI-使用了JSOUP-ASYNCTASK-CONSTRAINTLAYOUT-目前的功能有爬取指定页数的职位信息"><a href="#自己写了爬取V2ex上职位信息的小爬虫程序-作为最近的练手程序-界面非常丑陋，几乎没有什么UI-使用了JSOUP-ASYNCTASK-CONSTRAINTLAYOUT-目前的功能有爬取指定页数的职位信息" class="headerlink" title="自己写了爬取V2ex上职位信息的小爬虫程序,作为最近的练手程序,界面非常丑陋，几乎没有什么UI,使用了JSOUP+ASYNCTASK+CONSTRAINTLAYOUT,目前的功能有爬取指定页数的职位信息."></a>自己写了爬取V2ex上职位信息的小爬虫程序,作为最近的练手程序,界面非常丑陋，几乎没有什么UI,使用了JSOUP+ASYNCTASK+CONSTRAINTLAYOUT,目前的功能有爬取指定页数的职位信息.</h5><h6 id="欢迎看到的朋友们-虽然没什么人能看到…-fork-star-评论"><a href="#欢迎看到的朋友们-虽然没什么人能看到…-fork-star-评论" class="headerlink" title="欢迎看到的朋友们(虽然没什么人能看到….)fork star 评论!"></a>欢迎看到的朋友们(虽然没什么人能看到….)fork star 评论!</h6><p>我的小尾巴: 爱情不过是生活的屁.  i wanna money money money ….</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/08/22/Android爬虫-爬取V2ex职位信息/" data-id="cis63x2lt0000icp9kexqgn3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-AsyncTask的一些分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/19/AsyncTask的一些分析/" class="article-date">
  <time datetime="2016-08-19T08:14:09.000Z" itemprop="datePublished">2016-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/19/AsyncTask的一些分析/">AsyncTask的一些分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="关于AsyncTask的一些分析"><a href="#关于AsyncTask的一些分析" class="headerlink" title="关于AsyncTask的一些分析"></a>关于AsyncTask的一些分析</h5>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/08/19/AsyncTask的一些分析/" data-id="cis63x2m50006icp94ybetenz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-MzUpdate-DownloadCommon库分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/27/MzUpdate-DownloadCommon库分析/" class="article-date">
  <time datetime="2016-07-27T02:04:55.000Z" itemprop="datePublished">2016-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/27/MzUpdate-DownloadCommon库分析/">MzUpdate-DownloadCommon库分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于MzUpdate应用中Download库的分析"><a href="#关于MzUpdate应用中Download库的分析" class="headerlink" title=" 关于MzUpdate应用中Download库的分析."></a> 关于MzUpdate应用中Download库的分析.</h1><h2 id="核心类ThreadPool"><a href="#核心类ThreadPool" class="headerlink" title=" 核心类ThreadPool"></a> 核心类ThreadPool</h2><p>TheadPool是自定义类,类中定义了一些与操作线程有关的变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">10</span>; <span class="comment">// 10 seconds</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource type</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_NONE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_CPU = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_NETWORK = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">ResourceCounter mCpuCounter = <span class="keyword">new</span> ResourceCounter(<span class="number">2</span>);</span><br><span class="line">ResourceCounter mNetworkCounter = <span class="keyword">new</span> ResourceCounter(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadPool sThreadPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor mExecutor;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong> CORE_POOL_SIZE </strong>：核心线程即使处于idle状态也会被保存在线程池中.</li>
<li><p><strong>KEEP_ALIVE_TIME</strong> : 当线程池中线程数量超过线程池上限,idle状态的线程会被保存的最久的时间.</p>
</li>
<li><p><strong>sThreadPool</strong> : ThreadPool类保存一个本身的静态单例对象供调用.</p>
</li>
<li><strong>mExecutor</strong>  : ThreadPoolExecutor类型的变量</li>
</ul>
<h4 id="ThreadExecutor简单分析"><a href="#ThreadExecutor简单分析" class="headerlink" title="ThreadExecutor简单分析"></a>ThreadExecutor简单分析</h4><p><img src="http://oaydkbbin.bkt.clouddn.com/image/markdown/executorservice.bmpExecutorService.bmp" alt="Executor结构"></p>
<p>ExecutorService接口实现了Executor接口,官方文档这里描述它<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecuteService 是一个Executor,可以提供方法来管理线程的终止并产生一个Future来监控一个或多个异步任务的进度.Executor被关闭的时候将不会再添加新的任务.ExecutorService提供了两个关闭的方法,shutDown()和shutDownNow().</span><br><span class="line"></span><br><span class="line">shutDonw()方法会等待线程池中的线程完成任务之后再进行关闭</span><br><span class="line"></span><br><span class="line">shutDownNow()方法则不管线程的完成情况,会立即进行关闭动作.</span><br><span class="line"></span><br><span class="line">submit():运行一个Runnable任务并返回一个Future,如果task为null会抛出NullPointer异常,如果task不能被调度或者执行就会抛出RejectedExecutionException.该方法会返回一个Future对象,</span><br></pre></td></tr></table></figure></p>
<p>抽象类AbstractExecutorService 实现了接口ExecutorService.<br>它会返回一个RunnableFuture对象,并调用execute()方法来执行该任务,而execute()方法和shutdown()等方法均未在AbstractExecuteService中实现,他们的实现都放在ThreadPoolExecutor中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span><br><span class="line"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="ThreadPool的官方文档时这样描述的"><a href="#ThreadPool的官方文档时这样描述的" class="headerlink" title="ThreadPool的官方文档时这样描述的"></a>ThreadPool的官方文档时这样描述的</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在执行大量的异步任务的时候,线程池通常能有很好的性能,这归功与执行每个task的消耗的减少,并且线程池提供了一种方法来绑定和管理资源(包括线程).线程池也包含了一些基本的数据,例如已完成的任务数量等.</span><br><span class="line">为了能在一系列环境中都起到作用,这个类提供了许多可调节的参数和可供扩展的回调.</span><br><span class="line">但是,开发者们通常更乐意使用工厂方法返回的实例.例如newCachedThreadPool(未绑定的线程池,会自动进行线程的释放),newSingleThreadExecutor(只使用一个后台线程),newFixedThreadPool(大小固定的线程池).</span><br><span class="line">每当有新任务要处理的时候,如果此时核心线程池中的线程数量没有到达最大,一个新线程就会创造出来来处理这个请求,即使其它剩下的工作线程仍处于idle状态.</span><br><span class="line">但我们仍然可以通过手动的方式来控制核心线程池的数量以及线程池的最大线程数,当任务队列非空的时候我们也可以预先将线程全部初始化.</span><br><span class="line">如果目前线程池中的线程数量已经到达了最大值,一旦当线程池中的线程处于idle状态的时间超过了KeepAliveTime，这提供了一种机制,当线程池处于不活跃的状态的时候减少消耗,一般来说这种机制只作用与核心线程池之外的线程,但可以通过allowThreadTimeOut()方法手动设置只要keepAliveTime不为0即可.</span><br><span class="line">同时BlockingQueue会被配合使用:当线程数量没有填满核心线程池的时候,Executor会更偏向与添加新线程来执行任务,而不是阻塞任务.如果队列是非阻塞的,那么除非线程数量达到了最大,线程池会建立一个新的线程,否则该任务会被rejected.</span><br><span class="line">ThreadPool中使用的队列种类:</span><br><span class="line">1.Direct handoffs队列,例如SynchronousQueue,同步队列会直接将任务入队而不是保留他们,此时如果没有线程能立刻执行它,任务的入队操作就会失败,</span><br><span class="line">2.Unbounded queues例如LinkedBlockingQueue,入队的任务数量不受限制,当所有核心线程均处于忙碌状态时,新任务将会在队列中等待.这种队列在处理短暂的任务时会显得平滑,然而当任务增加的速度大于处理速度的时候就会造成任务的堆积.</span><br><span class="line">3.有限的队列,例如ArrayBlockingQueue,当线程池的最大数量确定的时候这种队列有助于防止资源的枯竭,但会变得难以调节控制。队列大小和线程池最大数量需要互相权衡:使用大队列和较小的线程池上限能最小化cpu的使用率以及操作系统资源和上下文环境切换的开销,但却会人为地导致低产出.比如当任务经常因为IO读写而阻塞,比起开发者的设定系统通常能更好的将事件调度给更多的线程.使用较小的队列通常需要干更大的线程池,这样会导致cpu变得更忙碌但可能会导致难以接受的调度开销,同时会导致低产出.</span><br><span class="line"></span><br><span class="line">当Executor被关闭的时候,提交到execute()方法的新任务将会被rejected.当队列有限或者线程数量有上限的时候也是相同的情况.</span><br><span class="line">当tasks被rejected的时候,execute()方法会执行RejectedExecutionHandler的rejectedExecutionHandler()方法.</span><br><span class="line">android提供了四种预定义的策略.</span><br><span class="line"></span><br><span class="line">1.AbortPolicy : 抛出runtime异常,RejectedExecutionExeception.</span><br><span class="line">2.CallerRunsPolicy : 调用execute()方法的线程来执行任务.这提供了一种简单的反馈机制来减慢新任务被提交的速度.</span><br><span class="line">3.DiscardPolicy : 无法执行的任务就会被丢弃.</span><br><span class="line">4.DiscardOldestPolicy: 如果executor没有关闭,工作队列的第一个任务会被丢弃，然后execution会重新尝试.</span><br><span class="line"></span><br><span class="line">getQueue()返回work queue的实例以供加锁监控和调试.因为其它目的使用该方法都是不被鼓励的.</span><br><span class="line"></span><br><span class="line">程序中不再保留线程的线程池会自动被回收.如果你想要保证在忘记调用shutdown方法的情况下也保证没有引用的线程池也被回收,你就要通过设定合适的keep-alive时间保证无用的线程最终消亡.</span><br></pre></td></tr></table></figure>
<h5 id="Worker对象"><a href="#Worker对象" class="headerlink" title="Worker对象"></a>Worker对象</h5><p>内部持有Thread对象,管理线程执行任务的情况.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/07/27/MzUpdate-DownloadCommon库分析/" data-id="cis63x2mr000dicp9as80xs0p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-shell脚本删除空目录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/17/shell脚本删除空目录/" class="article-date">
  <time datetime="2016-07-17T06:02:26.000Z" itemprop="datePublished">2016-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/17/shell脚本删除空目录/">shell脚本删除空目录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="最近学习shell编程-于是写一个删除所有空目录的脚本来练手-刚开始的想法是从”ls”命令的输出来判断当前的目录底下是否为空"><a href="#最近学习shell编程-于是写一个删除所有空目录的脚本来练手-刚开始的想法是从”ls”命令的输出来判断当前的目录底下是否为空" class="headerlink" title="最近学习shell编程,于是写一个删除所有空目录的脚本来练手,刚开始的想法是从”ls”命令的输出来判断当前的目录底下是否为空"></a>最近学习shell编程,于是写一个删除所有空目录的脚本来练手,刚开始的想法是从”ls”命令的输出来判断当前的目录底下是否为空</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#编写一个可以自动清除所有空目录的脚本</span><br><span class="line">function circleDelete()&#123;</span><br><span class="line">  for file in `ls $1`</span><br><span class="line">  do</span><br><span class="line">    if [ -d $1&quot;/&quot;$file ]</span><br><span class="line">    then</span><br><span class="line">      if [[ &quot;`ls $1&quot;/&quot;$file`&quot;=&quot;&quot; ]]</span><br><span class="line">      then</span><br><span class="line">        echo &quot;`ls $1&quot;/&quot;$file`&quot;</span><br><span class="line">        echo &quot;is empty&quot;</span><br><span class="line">      else</span><br><span class="line">        echo &quot;not empty&quot;</span><br><span class="line">      fi</span><br><span class="line">      circleDelete $1&quot;/&quot;$file;</span><br><span class="line">    else</span><br><span class="line">      echo &apos;none&apos;;</span><br><span class="line">    fi</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line">circleDelete $1</span><br></pre></td></tr></table></figure>
<h5 id="不过这种直接与空字符串比较的方法似乎并不起作用-亲测并不能判断出当前的目录是否为空"><a href="#不过这种直接与空字符串比较的方法似乎并不起作用-亲测并不能判断出当前的目录是否为空" class="headerlink" title="不过这种直接与空字符串比较的方法似乎并不起作用,亲测并不能判断出当前的目录是否为空"></a>不过这种直接与空字符串比较的方法似乎并不起作用,亲测并不能判断出当前的目录是否为空</h5><h5 id="之后发现一种更好用的方法-就是直接调用linux中的命令-FIND。"><a href="#之后发现一种更好用的方法-就是直接调用linux中的命令-FIND。" class="headerlink" title="之后发现一种更好用的方法,就是直接调用linux中的命令  FIND。"></a>之后发现一种更好用的方法,就是直接调用linux中的命令  <strong>FIND</strong>。</h5><p>直接用这行命令就可以查找出所有的空目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find path -empty -type d</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/07/17/shell脚本删除空目录/" data-id="cis63x2mo000bicp9lflbdy2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-WeakHanlder分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/WeakHanlder分析/" class="article-date">
  <time datetime="2016-07-06T08:04:02.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/WeakHanlder分析/">WeakHanlder分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="为什么要使用WeakHandler"><a href="#为什么要使用WeakHandler" class="headerlink" title="为什么要使用WeakHandler"></a>为什么要使用WeakHandler</h3><p>在使用Handler的时候,通常的写法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler mHandler = new Handler();</span><br></pre></td></tr></table></figure></p>
<p>通过handler的<strong>sendDelayedMessage()</strong>方法可以发送Message或者Runnable.当我们延时发送一条message或者延时执行某个runable的时候,如果在这个时候退出activity,由于消息队列中的每条message都持有handler引用而消息队列是与app生命周期相同的全程存在.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain(Handler h) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line"></span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>会导致handler无法释放。<br>而从java的角度来考虑,因为所有的非静态内部类和匿名内部类都会持有对外部类的引用,所以非静态的handler自然会持有对外部对象activity的引用.<br>这样就会导致在message延时的时间内activity的资源无法被回收,从而造成内存泄露.</p>
<h3 id="WeakHandler的组成和分析"><a href="#WeakHandler的组成和分析" class="headerlink" title="WeakHandler的组成和分析"></a>WeakHandler的组成和分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Handler.Callback mCallback; <span class="comment">// hard reference to Callback. We need to keep callback in memory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecHandler mExec;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ChainedRef mRunnables = <span class="keyword">new</span> ChainedRef(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>weakhandler中包含三个对象,Handler内的<strong>Callback</strong>对象,一个<strong>ExecHandler</strong>对象,还有一个存储runnables对象的<strong>mRunnables</strong>.</p>
<h4 id="ExecHandler"><a href="#ExecHandler" class="headerlink" title="ExecHandler"></a>ExecHandler</h4><p>callback回调函数会传入exechandler中,exechandler负责callback的执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> Handler.Callback callback = mCallback.get();</span><br><span class="line">        <span class="keyword">if</span> (callback == <span class="keyword">null</span>) &#123; <span class="comment">// Already disposed</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callback.handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="mRunnables"><a href="#mRunnables" class="headerlink" title="mRunnables"></a>mRunnables</h4><p>Handler之所以会西楼</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/07/06/WeakHanlder分析/" data-id="cis63x2mq000cicp9t33whw55" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-CherryPick和几个关于git的问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/06/CherryPick和几个关于git的问题总结/" class="article-date">
  <time datetime="2016-07-06T06:04:38.000Z" itemprop="datePublished">2016-07-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/06/CherryPick和几个关于git的问题总结/">CherryPick和几个关于git的问题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="关于git中的HEAD"><a href="#关于git中的HEAD" class="headerlink" title="关于git中的HEAD"></a>关于git中的HEAD</h3><p>HEAD可以理解为一个指针或者一个指向,它指向当前本地或者远程中的某个具体位置,<br>用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .git/HEAD</span><br></pre></td></tr></table></figure></p>
<p>命令可以查看到当前所在的本地分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref: refs/heads/dev</span><br></pre></td></tr></table></figure></p>
<p>使用<code>cd refs/</code>命令进入该路径下可以查看到<code>heads</code> <code>remotes</code> <code>tags</code>这几个文件夹.</p>
<p><code>heads</code>中存储了所有本地的分支.<code>remotes</code>存储了所有远程仓库,而<code>tag</code>则是程序员自己添加的标签.</p>
<h3 id="什么是detached-HEAD"><a href="#什么是detached-HEAD" class="headerlink" title="什么是detached HEAD"></a>什么是detached HEAD</h3><p>当使用 <code>git checkout</code>切换到远程仓库上的某个分支后,本地端的HEAD此时是没有指向某个具体的本地分支的,它指向的只是某次提交而已,在detached HEAD状态下我们仍然可以进行代码的修改和commit,也可以push到指定的远程分支上,只是当我们想要切换分支的时候可能会造成commit的丢失.</p>
<h6 id="在这种情况下可以使用git-checkout-b-branchname-切换到一个新的本地分支保存所有改动"><a href="#在这种情况下可以使用git-checkout-b-branchname-切换到一个新的本地分支保存所有改动" class="headerlink" title="在这种情况下可以使用git checkout -b branchname 切换到一个新的本地分支保存所有改动."></a>在这种情况下可以使用<code>git checkout -b branchname</code> 切换到一个新的本地分支保存所有改动.</h6><h3 id="CherryPick是什么"><a href="#CherryPick是什么" class="headerlink" title="CherryPick是什么"></a>CherryPick是什么</h3><p><code>cherrypick</code>命令相当于从任意分支上摘取某个commit将该commit应用到当前分支上,可能会产生冲突.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/07/06/CherryPick和几个关于git的问题总结/" data-id="cis63x2mf000aicp9uphjokb1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-Android-Input事件流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/20/Android-Input事件流程/" class="article-date">
  <time datetime="2016-04-20T06:59:02.000Z" itemprop="datePublished">2016-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/20/Android-Input事件流程/">Android-Input事件流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://upload-images.jianshu.io/upload_images/1254064-21693fde0f487a60?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1254064-2e1b18f9862fb250?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="一-input-系统初始化"><a href="#一-input-系统初始化" class="headerlink" title="一.input 系统初始化"></a>一.input 系统初始化</h3><p>安卓系统启动时,会开启SystemServer进程,SystemServer执行main函数,调用<strong>startOtherService()</strong>初始化windowManagerService和InputManagerService等<br>InputManagerService的构造函数如下,<strong>mPtr</strong>是一个指向nativeInputManager对象的指针.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line">LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br></pre></td></tr></table></figure></p>
<p>这里的nativeInit方法调用到<strong>com_android_server_input_InputManagerService.cpp</strong>中NativeInputManager的构造函数<br>这里会构造一个<strong>EventHub</strong>对象并将它传入InputManager的构造函数中,<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">321</span>    sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line"><span class="number">322</span>    mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span>InputManager::InputManager(</span><br><span class="line"><span class="number">28</span>        <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line"><span class="number">29</span>        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line"><span class="number">30</span>        <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line"><span class="number">31</span>    mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line"><span class="number">32</span>    mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line"><span class="number">33</span>    initialize();</span><br><span class="line"><span class="number">34</span>&#125;</span><br></pre></td></tr></table></figure>
<p>initialize函数中会设置两个线程来运行InputReader和InputDispatcher<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">49</span>    mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line"><span class="number">50</span>    mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br></pre></td></tr></table></figure></p>
<p>inputManagerService会设置一个回调,供windowManager调用,之后会调用inputManager的start()方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                    mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                    !mFirstBoot, mOnlyCore);</span><br><span class="line">inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">inputManager.start();</span><br></pre></td></tr></table></figure></p>
<p>start方法会最终调用到InputManager.cpp 文件中的  <strong>status_t InputManager::start()</strong>函数<br>主要步骤如下,运行dispatcherThread的run()方法和mReaderThread的run()方法.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54</span>    <span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="number">55</span>    <span class="keyword">if</span> (result) &#123;</span><br><span class="line"><span class="number">56</span>        ALOGE(<span class="string">"Could not start InputDispatcher thread due to error %d."</span>, result);</span><br><span class="line"><span class="number">57</span>        <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">58</span>    &#125;</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">60</span>    result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="number">61</span>    <span class="keyword">if</span> (result) &#123;</span><br><span class="line"><span class="number">62</span>        ALOGE(<span class="string">"Could not start InputReader thread due to error %d."</span>, result);</span><br><span class="line"><span class="number">63</span></span><br><span class="line"><span class="number">64</span>        mDispatcherThread-&gt;requestExit();</span><br><span class="line"><span class="number">65</span>        <span class="keyword">return</span> result;</span><br><span class="line"><span class="number">66</span>    &#125;</span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">68</span>    <span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1254064-b86a163dc35ad334.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建位图图像.jpg"></p>
<h3 id="二-读取input-events"><a href="#二-读取input-events" class="headerlink" title="二.读取input events"></a>二.读取input events</h3><p>mReaderThread-&gt;run()方法会调用自身的 threadLoop()方法,进而调用mReader的loopOnce()方法,<br>loopOnce()方法主要分为三个主要的步骤.</p>
<p>####步骤一:<br>在该方法中会通过EventHub来获取input事件,计算缓冲区大小,判断是否有新的事件产生,然后用processEventsLocked()方法来处理events<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"><span class="number">314</span>        <span class="keyword">if</span> (count) &#123;</span><br><span class="line"><span class="number">315</span>            processEventsLocked(mEventBuffer, count);</span><br><span class="line"><span class="number">316</span>        &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二:"></a>步骤二:</h4><p>在processEventsLocked()方法中会调用<strong><em>processEventsForDeviceLocked(deviceId, rawEvent, batchSize)</em></strong>函数,该函数会确定设备编号并调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">531</span>    device-&gt;process(rawEvents, count);</span><br></pre></td></tr></table></figure></p>
<h4 id="安卓系统中每种输入设备都对应了一种Mapper-比如SwitchInputMapper-VibratorInputMapper-KeyBoardInputMapper"><a href="#安卓系统中每种输入设备都对应了一种Mapper-比如SwitchInputMapper-VibratorInputMapper-KeyBoardInputMapper" class="headerlink" title="安卓系统中每种输入设备都对应了一种Mapper,比如SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper"></a>安卓系统中每种输入设备都对应了一种Mapper,比如SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper</h4><h4 id="在process-函数中会调用对应mapper的processKey-函数-在该函数中具体处理不同的input事件"><a href="#在process-函数中会调用对应mapper的processKey-函数-在该函数中具体处理不同的input事件" class="headerlink" title="在process()函数中会调用对应mapper的processKey()函数,在该函数中具体处理不同的input事件"></a>在process()函数中会调用对应mapper的<strong>processKey()</strong>函数,在该函数中具体处理不同的input事件</h4><p>在processKey()函数中会调用   getListener()-&gt;notifyKey(),  也就是调用mQueuedListener.notifyKey();</p>
<p>而这个listener的notifyKey()方法只有一行代码,将notifyKeyArgs对象放入到mArgsQueue队列中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mArgsQueue.push(**<span class="keyword">new</span>** NotifyKeyArgs(*args));</span><br></pre></td></tr></table></figure></p>
<h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三:"></a>步骤三:</h3><p>最后一步会将mQueuedListener队列中的所有内容全部清空.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mQueuedListener-&gt;flush();</span><br></pre></td></tr></table></figure></p>
<p>flush()函数中将所有的NotifyArgs对象取出,依次执行args-&gt;notify()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">171</span><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line"><span class="number">172</span>    size_t count = mArgsQueue.size();</span><br><span class="line"><span class="number">173</span>    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"><span class="number">174</span>        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line"><span class="number">175</span>        args-&gt;notify(mInnerListener);</span><br><span class="line"><span class="number">176</span>        delete args;</span><br><span class="line"><span class="number">177</span>    &#125;</span><br><span class="line"><span class="number">178</span>    mArgsQueue.clear();</span><br><span class="line"><span class="number">179</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>而<strong>notify()</strong>函数会调用innnerListener的<strong>notifyKey()</strong>函数,innerListener实际上就是构造InputReader时传入的InputDispatcher,所以调用的就是InputDispatcher的notifyKey()函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">62</span><span class="keyword">void</span> NotifyKeyArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="number">63</span>    listener-&gt;notifyKey(<span class="keyword">this</span>);</span><br><span class="line"><span class="number">64</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>在notifyKey()函数中会新建一个KeyEvent对象并进行初始化,然后调用mPolicy的interceptKeyBeforeQueueing<strong>(</strong>mPolicy就是NativeInputManagers)__<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2548</span>    KeyEvent event;</span><br><span class="line"><span class="number">2549</span>    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line"><span class="number">2550</span>            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line"><span class="number">2551</span>            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"><span class="number">2552</span></span><br><span class="line"><span class="number">2553</span>    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br></pre></td></tr></table></figure></p>
<p>这里会在c++代码中调用java层的代码,会先把keyEvent转换为jobject对象，然后调用java层对应的interceptBeforeQueueing函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">894</span>        jobject keyEventObj = android_view_KeyEvent_fromNative(env, keyEvent);</span><br><span class="line"><span class="number">896</span>        <span class="keyword">if</span> (keyEventObj) &#123;</span><br><span class="line"><span class="number">897</span>            wmActions = env-&gt;CallIntMethod(mServiceObj,</span><br><span class="line"><span class="number">898</span>                    gServiceClassInfo.interceptKeyBeforeQueueing,</span><br><span class="line"><span class="number">899</span>                    keyEventObj, policyFlags);</span><br></pre></td></tr></table></figure></p>
<p>这里调用了native的interceptKeyBeforeQueueing函数,用到了在初始化时设定的一个windowManager持有的回调.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Native callback.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mWindowManagerCallbacks.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这个windowManager持有的回调，最终会调用到WindowPhoneManager的interceptKeyBeforeQueueing函数(mpolicy就是windowPhoneManager),这样以来对input的管理最终集中到了windowManager中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Provides an opportunity for the window manager policy to intercept early key</span><br><span class="line"> * processing as soon as the key has been read from the device. */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interceptKeyBeforeQueueing</span><span class="params">(KeyEvent event, <span class="keyword">int</span> policyFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.mPolicy.interceptKeyBeforeQueueing(event, policyFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>input events从java层的<strong><em>windowManagerService</em></strong>的拦截函数返回后,会继续在notify()函数中运行,这里会继续判断是否打开了过滤器开关,如果打开了就对event进行过滤,并返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2559</span>        <span class="keyword">if</span> (shouldSendKeyToInputFilterLocked(args)) &#123;</span><br><span class="line"><span class="number">2560</span>            mLock.unlock();</span><br><span class="line"><span class="number">2561</span></span><br><span class="line"><span class="number">2562</span>            policyFlags |= POLICY_FLAG_FILTERED;</span><br><span class="line"><span class="number">2563</span>            <span class="keyword">if</span> (!mPolicy-&gt;filterInputEvent(&amp;event, policyFlags)) &#123;</span><br><span class="line"><span class="number">2564</span>                <span class="keyword">return</span>; <span class="comment">// event was consumed by the filter</span></span><br><span class="line"><span class="number">2565</span>            &#125;</span><br><span class="line"><span class="number">2566</span></span><br><span class="line"><span class="number">2567</span>            mLock.lock();</span><br><span class="line"><span class="number">2568</span>        &#125;</span><br></pre></td></tr></table></figure></p>
<p>将event信息存储在一个KeyEntry对象中,调用enqueueInboundEventLocked函数并判断是否需要唤醒<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2571</span>        KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line"><span class="number">2572</span>                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line"><span class="number">2573</span>                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line"><span class="number">2574</span>                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"><span class="number">2575</span></span><br><span class="line"><span class="number">2576</span>        needWake = enqueueInboundEventLocked(newEntry);</span><br></pre></td></tr></table></figure></p>
<p>之后如果需要唤醒,就会调用<em>mLooper.wake()</em>唤醒分发线程进行事件分发.</p>
<h3 id="三-分发events到UI窗口"><a href="#三-分发events到UI窗口" class="headerlink" title="三.分发events到UI窗口"></a>三.分发events到UI窗口</h3><p>回到InputDispatcher中分析:<br>mDispatcherThread::threadLoop()方法中会调用<em>dispatchOnce()</em>函数,该函数中主要调用两个方法一个是<br><strong>DispatchOnceInnerLocked()</strong>函数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">319</span>        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line"><span class="number">320</span>            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line"><span class="number">321</span>        &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要会调用到<em>pokeUserActivityLocked()</em>函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">394</span>        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line"><span class="number">395</span>        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line"><span class="number">396</span>            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line"><span class="number">397</span>        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <em>pokeUserActivityLocked()</em>函数中会将key事件封装成系统需要处理的key事件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1902</span>    CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line"><span class="number">1903</span>            &amp; InputDispatcher::doPokeUserActivityLockedInterruptible);</span><br><span class="line"><span class="number">1904</span>    commandEntry-&gt;eventTime = eventEntry-&gt;eventTime;</span><br><span class="line"><span class="number">1905</span>    commandEntry-&gt;userActivityEventType = eventType;</span><br></pre></td></tr></table></figure></p>
<p>在这里会调用 <em>doPokeUserActivityLockedInterruptible</em>函数,函数中会调用NativeInputManager的pokeUserActivity函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPolicy-&gt;pokeUserActivity(commandEntry-&gt;eventTime, commandEntry-&gt;userActivityEventType);</span><br></pre></td></tr></table></figure></p>
<p>通过JNI调用到java层PowerManagerService中的 <em>userActivityFromNative</em>函数,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">106</span>        env-&gt;CallVoidMethod(gPowerManagerServiceObj,</span><br><span class="line"><span class="number">107</span>                gPowerManagerServiceClassInfo.userActivityFromNative,</span><br><span class="line"><span class="number">108</span>                nanoseconds_to_milliseconds(eventTime), eventType, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">userActivityInternal</span><span class="params">(<span class="keyword">long</span> eventTime, <span class="keyword">int</span> event, <span class="keyword">int</span> flags, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userActivityNoUpdateLocked(eventTime, event, flags, uid)) &#123;</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到<em>dispatchOnceInnerLocked</em>函数之后会对event的类型进行判断,按照event的类型进行不同的操作.<br>首先会调用 <em>findFocusedWindowTargetLocked</em>函数得到要对应的UI窗口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">875</span>    int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line"><span class="number">876</span>            entry, inputTargets, nextWakeupTime);</span><br></pre></td></tr></table></figure></p>
<p>如果是按键事件,会调用dispatchKeyLocked()函数,又会调用dispatchEventLocked()函数：<br>确定对应输出的UI窗口,并得到它们之间的connection.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1029</span>        <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line"><span class="number">1030</span></span><br><span class="line"><span class="number">1031</span>        ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br></pre></td></tr></table></figure></p>
<p>之后会调用_<a href="http://opengrok.rnd.meizu.com/source/s?refs=prepareDispatchCycleLocked&amp;project=M80_base" target="_blank" rel="external">prepareDispatchCycleLocked</a>_函数</p>
<p>之后会进入到enqueueDispatchEntriesLocked函数中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1945</span>            enqueueDispatchEntriesLocked(currentTime, connection,</span><br><span class="line"><span class="number">1946</span>                    splitMotionEntry, inputTarget);</span><br><span class="line"><span class="number">1947</span>            splitMotionEntry-&gt;release();</span><br></pre></td></tr></table></figure></p>
<p>connection中维护一个outboundQueue队列,这个队列中存储input与该window之间的事件.<br>如果队列为空,就开始循环分发.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1974</span>    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line"><span class="number">1975</span>    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line"><span class="number">1976</span>        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line"><span class="number">1977</span>    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在startDisplayCycleLocked函数中：<br>会不断地取出事件进行分发,具体的分发过程利用到了linux的epoll机制,后面有具体分析.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = connection-&gt;inputPublisher.publishMotionEvent</span><br></pre></td></tr></table></figure></p>
<p>操作完成后会释放掉pendingEvent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">478</span>    <span class="keyword">if</span> (done) &#123;</span><br><span class="line"><span class="number">479</span>        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line"><span class="number">480</span>            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line"><span class="number">481</span>        &#125;</span><br><span class="line"><span class="number">482</span>        mLastDropReason = dropReason;</span><br><span class="line"><span class="number">483</span></span><br><span class="line"><span class="number">484</span>        releasePendingEventLocked();</span><br><span class="line"><span class="number">485</span>        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line"><span class="number">486</span>    &#125;</span><br></pre></td></tr></table></figure></p>
<p>Looper利用epoll机制接收events,并调用callback回调的handleEvent方法.也就是NativeInputEventReceiver的<em>handleEvent()</em>  方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">361</span>            <span class="comment">// Invoke the callback.  Note that the file descriptor may be closed by</span></span><br><span class="line"><span class="number">362</span>            <span class="comment">// the callback (and potentially even reused) before the function returns so</span></span><br><span class="line"><span class="number">363</span>            <span class="comment">// we need to be a little careful when removing the file descriptor afterwards.</span></span><br><span class="line"><span class="number">364</span>            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br></pre></td></tr></table></figure></p>
<p>而为什么会调用到这个InputEventReciever呢,InputEventReceiver是在ViewRootImpl中的<em>setView()</em>方法中被声明的,它的构造函数中有两个变量: <em>mInputChannel</em>和 <em>Looper.myLooper()</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,        Looper.myLooper());</span><br></pre></td></tr></table></figure></p>
<p>而在InputEventReceiver的构造函数中,会先取得主线程的looper对象和client端的java层inputChannel对象,然后调用<em>NativeInit()</em>方法进行初始化.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mInputChannel = inputChannel;</span><br><span class="line">mMessageQueue = looper.getQueue();</span><br><span class="line">mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">        inputChannel, mMessageQueue);</span><br></pre></td></tr></table></figure></p>
<p>在JNI层,首先获得了inputChannel和messageQueue的指针,并构造一个NativeInputEventReceiver对象.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">352</span>    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line"><span class="number">353</span>            inputChannelObj);</span><br><span class="line"><span class="number">359</span>    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line"><span class="number">365</span>    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line"><span class="number">366</span>            receiverWeak, inputChannel, messageQueue);</span><br></pre></td></tr></table></figure></p>
<p>之后会调用receiver的<em>initialize()</em>方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">122</span>status_t NativeInputEventReceiver::initialize() &#123;</span><br><span class="line"><span class="number">123</span>    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line"><span class="number">124</span>    <span class="keyword">return</span> OK;</span><br><span class="line"><span class="number">125</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>setFdEvents</em>函数中,会将client端的inputChannel的socket文件描述符加入到Looper的监控中.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">162</span><span class="keyword">void</span> NativeInputEventReceiver::setFdEvents(<span class="keyword">int</span> events) &#123;</span><br><span class="line"><span class="number">163</span>    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line"><span class="number">164</span>        mFdEvents = events;</span><br><span class="line"><span class="number">165</span>        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line"><span class="number">166</span>        <span class="keyword">if</span> (events) &#123;</span><br><span class="line"><span class="number">167</span>            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, NULL);</span><br><span class="line"><span class="number">168</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">169</span>            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line"><span class="number">170</span>        &#125;</span><br><span class="line"><span class="number">171</span>    &#125;</span><br><span class="line"><span class="number">172</span>&#125;</span><br><span class="line"><span class="number">173</span></span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1254064-55e7e4d403f9bd67.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InitInputChannel.jpg"></p>
<p>当有消息到来的时候,会调用inputChannel对应的<em>NativeInputEventReceiver</em>回调函数.<br>它的<em>handleEvent()</em>函数中会调用consumeEvents函数,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status_t status = consumeEvents(env, <span class="keyword">false</span> <span class="comment">/*consumeBatches*/</span>, -<span class="number">1</span>, NULL);</span><br></pre></td></tr></table></figure></p>
<p>在 <em>consumeEvents()</em>函数中会调用到InputChannel的<em>receiveMessage</em>方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">493</span>            <span class="comment">// Receive a fresh message.</span></span><br><span class="line"><span class="number">494</span>            status_t result = mChannel-&gt;receiveMessage(&amp;mMsg);</span><br></pre></td></tr></table></figure></p>
<p>然后通过JNI调用到java层InputEventReceiver的<em>dispatchInputEvent()</em>回调函数.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">330</span> env-&gt;CallVoidMethod(receiverObj.get(),<span class="number">331</span> gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用到ViewRoot的<em>OnInputEvent()</em>方法,继而调用了<em>enqueuInputEvent()</em>方法,<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">    doProcessInputEvents();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleProcessInputEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后进入到<em>delieverInputEvent()</em>方法中,对stage进行判断,如果为空则结束分发,否则<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stage.deliver(q);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    finishInputEvent(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>deliver()</em>函数中会执行stage的onPorcess()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(q, onProcess(q));</span><br></pre></td></tr></table></figure></p>
<p>这里的stage时这样取值的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">    stage = mSyntheticInputStage;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里InputStage的设计用到了流水线或者叫 </p>
<h3 id="责任链的模式"><a href="#责任链的模式" class="headerlink" title="责任链的模式"></a>责任链的模式</h3><p><img src="http://upload-images.jianshu.io/upload_images/1254064-6564535b5aa60550.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InputStage结构.jpg"></p>
<p>InputStage有很多子类,所有InputStage类的构造方法都会传入一个InputStage类的变量,这样最终会形成流水线线式的处理结构,每经过一个InputStage对象的处理都会进行判断,看是否还需要将 events继续向前传输,如果需要就调用<em>forward()</em>函数让该变量中存储的下一个InputStage对象处理该events,如果不需要就调用<em>finish()</em>函数结束events的传输.<br>只需知道最终会调用到ViewRootImpl的<em>enqueueInputEvent()</em>方法.<br>该方法中会立即或者延迟处理events.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">    doProcessInputEvents();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    scheduleProcessInputEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在　<em>doProcessInputEvent()</em>方法中会判断是否要经过IME输入法框架处理.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br></pre></td></tr></table></figure></p>
<p>最后经过判断后会层层处理,最终进入到<em>view.dispatchKeyEvent()</em>方法中.</p>
<h3 id="四"><a href="#四" class="headerlink" title="四."></a>四.</h3><p>最后返回到<em>dispatchOnceLocked()</em>函数中,执行<em>runCommandsLockedInterruptible()</em>函数.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">323</span>        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line"><span class="number">324</span>        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line"><span class="number">325</span>        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line"><span class="number">326</span>            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line"><span class="number">327</span>        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="五-Epoll机制"><a href="#五-Epoll机制" class="headerlink" title="五.Epoll机制"></a>五.Epoll机制</h3><p><img src="http://upload-images.jianshu.io/upload_images/1254064-b6501417ab4d6716.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="epoll.jpg"><br>Looper-&gt;wake()函数利用了linux中的epoll机制。<br>首先,注册一个epoll的实例描述符,将所有的管道对象的fd都注册到该epoll实例上,利用epoll_wait函数来睡眠等待管道上IO事件的发生;<br>调用PollOnce()函数来启动epoll_wait的睡眠等待,而wake()函数则是向epoll中的管道写入一个字符来唤醒epoll_wait.</p>
<p>###六.InputChannel分析<br><img src="http://upload-images.jianshu.io/upload_images/1254064-da3e5a28868cc359?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1254064-a0d41cab68b60cdb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="InputChannel结构.jpeg"></p>
<ul>
<li><h4 id="首先是server端的inputChannel注册"><a href="#首先是server端的inputChannel注册" class="headerlink" title="首先是server端的inputChannel注册"></a>首先是server端的inputChannel注册</h4></li>
<li><p>首先打开一对InputChannelPair，调用到JNI中的<br> <a href="http://opengrok.rnd.meizu.com/source/s?refs=android_view_InputChannel_nativeOpenInputChannelPair&amp;project=M80_base" target="_blank" rel="external">android_view_InputChannel_nativeOpenInputChannelPair</a>方法,最终会调用到linux中的<em>socketPair()</em>函数打开一对socket管道,而inputChannel就是由socket管道来构建的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">184</span> outServerChannel = **<span class="keyword">new</span>** InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>inputChannel在WMS中注册,保存在一个WindowState的类中,WMS使用这对inputChannel的第一个</p>
</li>
<li><p>然后会调用<em>registerInputChannel</em>方法进行注册.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终会调用Native层的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将inputChannel和connection保存在映射表中,mLooper加入对该fd的监听,当有数据到来的时候会唤醒等待的线程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3511        sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line">3512</span><br><span class="line">3513        int fd = inputChannel-&gt;getFd();</span><br><span class="line">3514        mConnectionsByFd.add(fd, connection);</span><br><span class="line">3516        if (monitor) &#123;</span><br><span class="line">3517            mMonitoringChannels.push(inputChannel);</span><br><span class="line">3518        &#125;</span><br><span class="line">3519</span><br><span class="line">3520        mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this);</span><br></pre></td></tr></table></figure>
<ul>
<li>而当InputDispatcher分发消息时,会调用<em>InputChannel::sendMessage()</em>方法,该方法调用了linux socket中的send函数,向socket管道中写入数据.</li>
</ul>
<h3 id="client端inputChannel的注册"><a href="#client端inputChannel的注册" class="headerlink" title="client端inputChannel的注册"></a>client端inputChannel的注册</h3><p>WMS中创建的inputChannel跨进程传输到cilent端,转换为client端的inputChannel使用.</p>
<p>讲解java JNI的注册:<a href="http://my.oschina.net/u/157503/blog/" target="_blank" rel="external">http://my.oschina.net/u/157503/blog/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/04/20/Android-Input事件流程/" data-id="cis63x2m30004icp9gy05czzg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-4-18学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/18/4-18学习总结/" class="article-date">
  <time datetime="2016-04-18T11:21:10.000Z" itemprop="datePublished">2016-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/18/4-18学习总结/">4-18学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="4-18号总结"><a href="#4-18号总结" class="headerlink" title="4-18号总结"></a>4-18号总结</h4><h4 id="GIT打包"><a href="#GIT打包" class="headerlink" title="GIT打包"></a>GIT打包</h4><h5 id="GIT打包是一种线下共享代码的方式-当有时候由于权限或者网络等原因无法在线拉取代码的时候-就可以使用git打包这种方式-打包的主要步骤如下"><a href="#GIT打包是一种线下共享代码的方式-当有时候由于权限或者网络等原因无法在线拉取代码的时候-就可以使用git打包这种方式-打包的主要步骤如下" class="headerlink" title="GIT打包是一种线下共享代码的方式,当有时候由于权限或者网络等原因无法在线拉取代码的时候,就可以使用git打包这种方式.打包的主要步骤如下."></a>GIT打包是一种线下共享代码的方式,当有时候由于权限或者网络等原因无法在线拉取代码的时候,就可以使用git打包这种方式.打包的主要步骤如下.</h5><ul>
<li>git bundle create repo.bundle HEAD master.  打包master分支,包含最近的一次提交</li>
<li>git fetch/pull repo.bundle master:local-master. 从repo.bundle中抽取出master分支合并到被合并的local-master分支.</li>
</ul>
<h5 id="还有一些额外的命令帮助打包"><a href="#还有一些额外的命令帮助打包" class="headerlink" title="还有一些额外的命令帮助打包:"></a>还有一些额外的命令帮助打包:</h5><ul>
<li>git log –oneline :查看历史提交记录</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/04/18/4-18学习总结/" data-id="cis63x2ly0001icp9iorwkls3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-AndroidDataBinding学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/15/AndroidDataBinding学习/" class="article-date">
  <time datetime="2016-04-15T09:02:02.000Z" itemprop="datePublished">2016-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/15/AndroidDataBinding学习/">AndroidDataBinding学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###AndroidDataBind准备步骤:</p>
<ul>
<li><h5 id="DataBind库是一个support-library-所以可以在任何平台上来使用"><a href="#DataBind库是一个support-library-所以可以在任何平台上来使用" class="headerlink" title="DataBind库是一个support library,所以可以在任何平台上来使用."></a>DataBind库是一个support library,所以可以在任何平台上来使用.</h5></li>
<li><h5 id="要使用Data-Binding-需要Android-Plugin-for-Gradle-1-5-0-alpha或更高版本"><a href="#要使用Data-Binding-需要Android-Plugin-for-Gradle-1-5-0-alpha或更高版本" class="headerlink" title="要使用Data Binding, 需要Android Plugin for Gradle 1.5.0-alpha或更高版本."></a>要使用Data Binding, 需要Android Plugin for Gradle 1.5.0-alpha或更高版本.</h5></li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/04/15/AndroidDataBinding学习/" data-id="cis63x2m40005icp9h1yecl5h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  
    l<article id="post-4-14问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/14/4-14问题记录/" class="article-date">
  <time datetime="2016-04-14T12:47:09.000Z" itemprop="datePublished">2016-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/14/4-14问题记录/">4-14问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="4-14工作及学习记录"><a href="#4-14工作及学习记录" class="headerlink" title="4-14工作及学习记录"></a>4-14工作及学习记录</h3><ul>
<li><h4 id="今天主要在解一个bug"><a href="#今天主要在解一个bug" class="headerlink" title="今天主要在解一个bug:"></a>今天主要在解一个bug:</h4>在EmptyDialog这个Activity类启动dialog的时候,点击确定按钮后没有弹出新的对话框,原因是前一个dialog还没有小毁掉就启动了相同的Activity.<br>解决方法是在第二次调用EmptyDialog这个Activity的时候利用handler延迟了启动,使得activity销毁后再重新建立.</li>
</ul>
<h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录:"></a>问题记录:</h3><h5 id="写了一个shell脚本打算通过adb-push到手机中-通过远程shell一直无法执行这个sh文件-已经获得root权限并且该文件也具有可执行权限-但是执行的时候仍然提示错误-No-Such-File-Or-Directory"><a href="#写了一个shell脚本打算通过adb-push到手机中-通过远程shell一直无法执行这个sh文件-已经获得root权限并且该文件也具有可执行权限-但是执行的时候仍然提示错误-No-Such-File-Or-Directory" class="headerlink" title="写了一个shell脚本打算通过adb push到手机中,通过远程shell一直无法执行这个sh文件.已经获得root权限并且该文件也具有可执行权限,但是执行的时候仍然提示错误 : No Such File Or Directory!"></a>写了一个shell脚本打算通过adb push到手机中,通过远程shell一直无法执行这个sh文件.已经获得root权限并且该文件也具有可执行权限,但是执行的时候仍然提示错误 : No Such File Or Directory!</h5><p>目前还不知道为什么.<br>替代方法是:在sh脚本文件中的shell命令之前加上 adb shell.不登陆远程shell来执行命令.<strong>但是以后可能会有需要将sh文件放入到手机中来执行的情况</strong>,</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blog.zhaoyang.meizu.com/2016/04/14/4-14问题记录/" data-id="cis63x2m90008icp9rcptgwjq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>

  

  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/22/Android爬虫-爬取V2ex职位信息/">Android爬虫-爬取V2ex职位信息</a>
          </li>
        
          <li>
            <a href="/2016/08/19/AsyncTask的一些分析/">AsyncTask的一些分析</a>
          </li>
        
          <li>
            <a href="/2016/07/27/MzUpdate-DownloadCommon库分析/">MzUpdate-DownloadCommon库分析</a>
          </li>
        
          <li>
            <a href="/2016/07/17/shell脚本删除空目录/">shell脚本删除空目录</a>
          </li>
        
          <li>
            <a href="/2016/07/06/WeakHanlder分析/">WeakHanlder分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget tag">
<h3 class="title">诚意满满的友情链接</h3>
<ul class="entry"> 
<li><a href="http://hoyoung.net" title="胡总的 Blog">HuYoung!</a></li>
<li><a href="http://blog.mtxcxin.cn" title="鹏总的 Blog">MTXC_YP!</a></li>
<li><a href="http://blog.csdn.net/liang 16286" title="梁神的 Blog">Liang God!</a></li>
</ul>
</div>

  
</aside>
        
      </div>
      < footer id = "footer" >
	 < div class = "outer" >
	< script async src = "https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" >
	< /script> < div id = "footer-info"
class = "inner" >
	& copy;
2016
人海中一只羊 < br >
	Powered by < a href = "http://hexo.io/"
target = "_blank" > Hexo-ZY < /a> < span id = "busuanzi_container_site_pv" >
本站总访问量 < span id = "busuanzi_value_site_pv" > < /span>次 < /span > < /div> < /div > < /footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>